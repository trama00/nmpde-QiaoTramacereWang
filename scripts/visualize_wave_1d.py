#!/usr/bin/env python3
"""
Visualize 1D wave equation solution from VTK files as animated GIF.

Usage:
    python visualize_wave_1d.py [--dir OUTPUT_DIR] [--prefix PREFIX] [--out wave_1d.gif] [--fps 15]
    
This script reads VTU files generated by the wave solver and creates an
animated visualization. For 1D case (dim=1), the solution is plotted as
u(x) vs x for each time step.

For 2D data sliced to 1D, it takes a line cut at y=0.5.
"""

import argparse
import glob
import os
import re
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter


def read_vtu_1d(filename):
    """
    Read VTU file and extract 1D data.
    Returns (x_coords, u_values, v_values).
    """
    try:
        import meshio
        mesh = meshio.read(filename)
        points = mesh.points
        
        # Get coordinates
        x = points[:, 0]
        
        # Get solution data
        u = mesh.point_data.get('U', np.zeros_like(x))
        v = mesh.point_data.get('V', np.zeros_like(x))
        
        # Sort by x coordinate for clean plotting
        sort_idx = np.argsort(x)
        return x[sort_idx], u[sort_idx], v[sort_idx]
        
    except ImportError:
        print("Error: meshio not installed. Install with: pip install meshio")
        raise


def read_vtu_2d_slice(filename, y_slice=0.5, tol=0.05):
    """
    Read 2D VTU file and extract 1D slice at y=y_slice.
    Returns (x_coords, u_values, v_values).
    """
    try:
        import meshio
        mesh = meshio.read(filename)
        points = mesh.points
        
        x = points[:, 0]
        y = points[:, 1]
        
        # Get solution data
        u = mesh.point_data.get('U', np.zeros_like(x))
        v = mesh.point_data.get('V', np.zeros_like(x))
        
        # Find points near y_slice
        mask = np.abs(y - y_slice) < tol
        if not np.any(mask):
            # Fall back to closest y value
            unique_y = np.unique(y)
            closest_y = unique_y[np.argmin(np.abs(unique_y - y_slice))]
            mask = np.abs(y - closest_y) < 1e-10
        
        x_slice = x[mask]
        u_slice = u[mask]
        v_slice = v[mask]
        
        # Sort by x
        sort_idx = np.argsort(x_slice)
        return x_slice[sort_idx], u_slice[sort_idx], v_slice[sort_idx]
        
    except ImportError:
        print("Error: meshio not installed. Install with: pip install meshio")
        raise


def find_vtu_files(directory, prefix="output"):
    """
    Find all VTU files in directory matching the pattern.
    Returns list of (timestep, filename) tuples sorted by timestep.
    Only reads .vtu files (not .pvtu which are parallel index files).
    """
    # Pattern: output_XXXXX.vtu or output.pvtu etc.
    pattern = os.path.join(directory, f"{prefix}*.vtu")
    files = glob.glob(pattern)
    
    # Filter out .pvtu files - only keep .vtu
    files = [f for f in files if f.endswith('.vtu') and not f.endswith('.pvtu')]
    
    results = []
    seen_timesteps = set()
    for f in files:
        # Extract timestep from filename
        basename = os.path.basename(f)
        # Match patterns like output_000.0.vtu -> timestep 0
        match = re.search(r'_(\d+)', basename)
        if match:
            timestep = int(match.group(1))
            # Only add one file per timestep
            if timestep not in seen_timesteps:
                results.append((timestep, f))
                seen_timesteps.add(timestep)
    
    # Sort by timestep
    results.sort(key=lambda x: x[0])
    return results


def create_animation_1d(vtu_files, output_file="wave_1d.gif", fps=15, 
                        y_slice=0.5, is_2d=False, show=True):
    """
    Create animated GIF from VTU files.
    """
    if not vtu_files:
        print("No VTU files found!")
        return
    
    print(f"Found {len(vtu_files)} VTU files")
    
    # Read first file to set up plot
    timestep0, file0 = vtu_files[0]
    if is_2d:
        x0, u0, v0 = read_vtu_2d_slice(file0, y_slice)
    else:
        x0, u0, v0 = read_vtu_1d(file0)
    
    # Determine plot limits by reading all data
    u_min, u_max = np.min(u0), np.max(u0)
    for ts, f in vtu_files[1:]:
        if is_2d:
            _, u, _ = read_vtu_2d_slice(f, y_slice)
        else:
            _, u, _ = read_vtu_1d(f)
        u_min = min(u_min, np.min(u))
        u_max = max(u_max, np.max(u))
    
    # Add some margin
    margin = 0.1 * (u_max - u_min) if u_max > u_min else 0.1
    u_min -= margin
    u_max += margin
    
    # Create figure
    fig, ax = plt.subplots(figsize=(10, 6))
    line, = ax.plot([], [], 'b-', linewidth=2, label='u(x,t)')
    ax.set_xlim(np.min(x0) - 0.05, np.max(x0) + 0.05)
    ax.set_ylim(u_min, u_max)
    ax.set_xlabel('x', fontsize=12)
    ax.set_ylabel('u(x,t)', fontsize=12)
    ax.set_title('Wave Equation Solution (1D)', fontsize=14)
    ax.grid(True, alpha=0.3)
    ax.legend(loc='upper right')
    
    time_text = ax.text(0.02, 0.95, '', transform=ax.transAxes, fontsize=12,
                        verticalalignment='top', bbox=dict(boxstyle='round', 
                        facecolor='wheat', alpha=0.5))
    
    def init():
        line.set_data([], [])
        time_text.set_text('')
        return line, time_text
    
    def animate(i):
        timestep, filename = vtu_files[i]
        if is_2d:
            x, u, _ = read_vtu_2d_slice(filename, y_slice)
        else:
            x, u, _ = read_vtu_1d(filename)
        line.set_data(x, u)
        time_text.set_text(f'Step: {timestep}')
        return line, time_text
    
    print(f"Creating animation with {len(vtu_files)} frames at {fps} fps...")
    anim = FuncAnimation(fig, animate, init_func=init, frames=len(vtu_files),
                         interval=1000/fps, blit=True)
    
    # Save GIF
    print(f"Saving to {output_file}...")
    writer = PillowWriter(fps=fps)
    anim.save(output_file, writer=writer)
    print(f"Animation saved to {output_file}")
    
    if show:
        plt.show()
    else:
        plt.close(fig)


def main():
    parser = argparse.ArgumentParser(
        description="Visualize 1D wave equation solution from VTU files as animated GIF"
    )
    parser.add_argument("--dir", default=".", 
                        help="Directory containing VTU files (default: current directory)")
    parser.add_argument("--prefix", default="output",
                        help="VTU filename prefix (default: output)")
    parser.add_argument("--out", default="wave_1d.gif",
                        help="Output GIF filename (default: wave_1d.gif)")
    parser.add_argument("--fps", type=int, default=15,
                        help="Frames per second (default: 15)")
    parser.add_argument("--y-slice", type=float, default=0.5,
                        help="Y coordinate for 2D slice (default: 0.5)")
    parser.add_argument("--is-2d", action="store_true",
                        help="Treat input as 2D data and take y-slice")
    parser.add_argument("--no-show", action="store_true",
                        help="Don't display the animation window")
    
    args = parser.parse_args()
    
    # Find VTU files
    vtu_files = find_vtu_files(args.dir, args.prefix)
    
    if not vtu_files:
        print(f"No VTU files found in {args.dir} with prefix '{args.prefix}'")
        print("Looking for .vtu files...")
        all_vtu = glob.glob(os.path.join(args.dir, "*.vtu"))
        if all_vtu:
            print(f"Found these VTU files: {all_vtu[:5]}...")
        return
    
    create_animation_1d(vtu_files, args.out, args.fps, args.y_slice, 
                        args.is_2d, show=not args.no_show)


if __name__ == "__main__":
    main()
