#!/usr/bin/env python3
"""
Visualize 2D wave equation solution from VTK files as animated GIF.

Usage:
    python visualize_wave_2d.py [--dir OUTPUT_DIR] [--prefix PREFIX] [--out wave_2d.gif] [--fps 10]
    
This script reads VTU files generated by the 2D wave solver and creates an
animated surface/contour visualization.
"""

import argparse
import glob
import os
import re
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.tri as mtri


def read_vtu_2d(filename):
    """
    Read 2D VTU file and extract data.
    Returns (x, y, u, v, triangles).
    """
    try:
        import meshio
        mesh = meshio.read(filename)
        points = mesh.points
        
        x = points[:, 0]
        y = points[:, 1]
        
        # Get solution data
        u = mesh.point_data.get('U', np.zeros_like(x))
        v = mesh.point_data.get('V', np.zeros_like(x))
        
        # Get triangles (cells)
        triangles = None
        for cell_block in mesh.cells:
            if cell_block.type == "triangle":
                triangles = cell_block.data
                break
        
        if triangles is None:
            # Fall back to Delaunay triangulation
            tri = mtri.Triangulation(x, y)
            triangles = tri.triangles
        
        return x, y, u, v, triangles
        
    except ImportError:
        print("Error: meshio not installed. Install with: pip install meshio")
        raise


def find_vtu_files(directory, prefix="output"):
    """
    Find all VTU files in directory matching the pattern.
    Returns list of (timestep, filename) tuples sorted by timestep.
    Only reads .vtu files (not .pvtu which are parallel index files).
    """
    pattern = os.path.join(directory, f"{prefix}*.vtu")
    files = glob.glob(pattern)
    
    # Filter out .pvtu files - only keep .vtu
    files = [f for f in files if f.endswith('.vtu') and not f.endswith('.pvtu')]
    
    results = []
    seen_timesteps = set()
    for f in files:
        basename = os.path.basename(f)
        # Match patterns like output_000.0.vtu -> timestep 0
        match = re.search(r'_(\d+)', basename)
        if match:
            timestep = int(match.group(1))
            # Only add one file per timestep (avoid duplicates from parallel runs)
            if timestep not in seen_timesteps:
                results.append((timestep, f))
                seen_timesteps.add(timestep)
    
    results.sort(key=lambda x: x[0])
    return results


def create_animation_2d_surface(vtu_files, output_file="wave_2d.gif", fps=10, 
                                show=True, cmap='viridis'):
    """
    Create animated 3D surface GIF from VTU files.
    """
    if not vtu_files:
        print("No VTU files found!")
        return
    
    print(f"Found {len(vtu_files)} VTU files")
    
    # Read first file to set up plot
    timestep0, file0 = vtu_files[0]
    x0, y0, u0, _, tri0 = read_vtu_2d(file0)
    
    # Determine u limits
    u_min, u_max = np.min(u0), np.max(u0)
    for ts, f in vtu_files[1:]:
        _, _, u, _, _ = read_vtu_2d(f)
        u_min = min(u_min, np.min(u))
        u_max = max(u_max, np.max(u))
    
    margin = 0.1 * (u_max - u_min) if u_max > u_min else 0.1
    u_min -= margin
    u_max += margin
    
    # Create figure with 3D axes
    fig = plt.figure(figsize=(12, 9))
    ax = fig.add_subplot(111, projection='3d')
    
    # Create triangulation
    triang = mtri.Triangulation(x0, y0, tri0)
    
    # Initial plot
    surf = ax.plot_trisurf(triang, u0, cmap=cmap, linewidth=0.1, 
                           antialiased=True, vmin=u_min, vmax=u_max)
    
    ax.set_xlim(np.min(x0), np.max(x0))
    ax.set_ylim(np.min(y0), np.max(y0))
    ax.set_zlim(u_min, u_max)
    ax.set_xlabel('x', fontsize=12)
    ax.set_ylabel('y', fontsize=12)
    ax.set_zlabel('u(x,y,t)', fontsize=12)
    ax.set_title('2D Wave Equation Solution', fontsize=14)
    
    # Colorbar
    cbar = fig.colorbar(surf, ax=ax, shrink=0.5, aspect=10, pad=0.1)
    cbar.set_label('u')
    
    time_text = ax.text2D(0.02, 0.95, '', transform=ax.transAxes, fontsize=12,
                          bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
    
    def update(frame):
        ax.clear()
        timestep, filename = vtu_files[frame]
        x, y, u, _, tri = read_vtu_2d(filename)
        triang = mtri.Triangulation(x, y, tri)
        
        surf = ax.plot_trisurf(triang, u, cmap=cmap, linewidth=0.1,
                               antialiased=True, vmin=u_min, vmax=u_max)
        
        ax.set_xlim(np.min(x), np.max(x))
        ax.set_ylim(np.min(y), np.max(y))
        ax.set_zlim(u_min, u_max)
        ax.set_xlabel('x', fontsize=12)
        ax.set_ylabel('y', fontsize=12)
        ax.set_zlabel('u(x,y,t)', fontsize=12)
        ax.set_title(f'2D Wave Equation Solution (Step {timestep})', fontsize=14)
        
        # Rotate view for better visualization
        ax.view_init(elev=30, azim=45 + frame * 0.5)
        
        return [surf]
    
    print(f"Creating 3D surface animation with {len(vtu_files)} frames at {fps} fps...")
    anim = FuncAnimation(fig, update, frames=len(vtu_files),
                         interval=1000/fps, blit=False)
    
    print(f"Saving to {output_file}...")
    writer = PillowWriter(fps=fps)
    anim.save(output_file, writer=writer)
    print(f"Animation saved to {output_file}")
    
    if show:
        plt.show()
    else:
        plt.close(fig)


def create_animation_2d_contour(vtu_files, output_file="wave_2d_contour.gif", 
                                fps=10, show=True, cmap='RdBu_r'):
    """
    Create animated 2D contour GIF from VTU files.
    """
    if not vtu_files:
        print("No VTU files found!")
        return
    
    print(f"Found {len(vtu_files)} VTU files")
    
    # Read first file
    timestep0, file0 = vtu_files[0]
    x0, y0, u0, _, tri0 = read_vtu_2d(file0)
    
    # Determine u limits
    u_min, u_max = np.min(u0), np.max(u0)
    for ts, f in vtu_files[1:]:
        _, _, u, _, _ = read_vtu_2d(f)
        u_min = min(u_min, np.min(u))
        u_max = max(u_max, np.max(u))
    
    # Symmetric colorbar around zero
    u_abs_max = max(abs(u_min), abs(u_max))
    
    # Create figure
    fig, ax = plt.subplots(figsize=(10, 8))
    
    triang = mtri.Triangulation(x0, y0, tri0)
    levels = np.linspace(-u_abs_max, u_abs_max, 21)
    
    # Initial contour
    tcf = ax.tricontourf(triang, u0, levels=levels, cmap=cmap)
    ax.tricontour(triang, u0, levels=levels, colors='k', linewidths=0.3, alpha=0.5)
    
    ax.set_xlim(np.min(x0), np.max(x0))
    ax.set_ylim(np.min(y0), np.max(y0))
    ax.set_xlabel('x', fontsize=12)
    ax.set_ylabel('y', fontsize=12)
    ax.set_title('2D Wave Equation Solution', fontsize=14)
    ax.set_aspect('equal')
    
    cbar = fig.colorbar(tcf, ax=ax, shrink=0.8)
    cbar.set_label('u(x,y,t)')
    
    time_text = ax.text(0.02, 0.98, '', transform=ax.transAxes, fontsize=12,
                        verticalalignment='top',
                        bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
    
    def update(frame):
        ax.clear()
        timestep, filename = vtu_files[frame]
        x, y, u, _, tri = read_vtu_2d(filename)
        triang = mtri.Triangulation(x, y, tri)
        
        tcf = ax.tricontourf(triang, u, levels=levels, cmap=cmap)
        ax.tricontour(triang, u, levels=levels, colors='k', linewidths=0.3, alpha=0.5)
        
        ax.set_xlim(np.min(x), np.max(x))
        ax.set_ylim(np.min(y), np.max(y))
        ax.set_xlabel('x', fontsize=12)
        ax.set_ylabel('y', fontsize=12)
        ax.set_title(f'2D Wave Equation (Step {timestep})', fontsize=14)
        ax.set_aspect('equal')
        ax.text(0.02, 0.98, f'Step: {timestep}', transform=ax.transAxes, fontsize=12,
                verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
        
        return []
    
    print(f"Creating contour animation with {len(vtu_files)} frames at {fps} fps...")
    anim = FuncAnimation(fig, update, frames=len(vtu_files),
                         interval=1000/fps, blit=False)
    
    print(f"Saving to {output_file}...")
    writer = PillowWriter(fps=fps)
    anim.save(output_file, writer=writer)
    print(f"Animation saved to {output_file}")
    
    if show:
        plt.show()
    else:
        plt.close(fig)


def main():
    parser = argparse.ArgumentParser(
        description="Visualize 2D wave equation solution from VTU files as animated GIF"
    )
    parser.add_argument("--dir", default=".",
                        help="Directory containing VTU files (default: current directory)")
    parser.add_argument("--prefix", default="output",
                        help="VTU filename prefix (default: output)")
    parser.add_argument("--out", default="wave_2d.gif",
                        help="Output GIF filename (default: wave_2d.gif)")
    parser.add_argument("--fps", type=int, default=10,
                        help="Frames per second (default: 10)")
    parser.add_argument("--mode", choices=['surface', 'contour', 'both'], 
                        default='contour',
                        help="Visualization mode: surface (3D), contour (2D), or both")
    parser.add_argument("--cmap", default="RdBu_r",
                        help="Colormap (default: RdBu_r)")
    parser.add_argument("--no-show", action="store_true",
                        help="Don't display the animation window")
    
    args = parser.parse_args()
    
    # Find VTU files
    vtu_files = find_vtu_files(args.dir, args.prefix)
    
    if not vtu_files:
        print(f"No VTU files found in {args.dir} with prefix '{args.prefix}'")
        all_vtu = glob.glob(os.path.join(args.dir, "*.vtu"))
        if all_vtu:
            print(f"Found these VTU files: {all_vtu[:5]}...")
        return
    
    show = not args.no_show
    
    if args.mode == 'surface':
        create_animation_2d_surface(vtu_files, args.out, args.fps, show, args.cmap)
    elif args.mode == 'contour':
        create_animation_2d_contour(vtu_files, args.out, args.fps, show, args.cmap)
    else:  # both
        # Surface
        out_surface = args.out.replace('.gif', '_surface.gif')
        create_animation_2d_surface(vtu_files, out_surface, args.fps, False, 'viridis')
        # Contour
        out_contour = args.out.replace('.gif', '_contour.gif')
        create_animation_2d_contour(vtu_files, out_contour, args.fps, show, args.cmap)


if __name__ == "__main__":
    main()
